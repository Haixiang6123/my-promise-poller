{"version":3,"sources":["webpack://ts-static-webapp-template/./src/lib/utils.ts","webpack://ts-static-webapp-template/./src/lib/contants.ts","webpack://ts-static-webapp-template/./src/lib/index.ts","webpack://ts-static-webapp-template/./src/index.ts"],"names":["CANCEL_TOKEN","delay","interval","Promise","resolve","setTimeout","strategies","defaults","getNextInterval","count","options","start","increment","min","max","Math","round","random","pow","timeoutId","strategy","mergedOptions","taskFn","masterTimeout","taskTimeout","shouldContinue","polling","rejections","retriesRemain","reject","window","Error","poll","taskResult","promise","taskPromise","then","result","clearTimeout","nextInterval","catch","error","message","push","$start","document","querySelector","$asyncStop","$fixedCounter","$linearCounter","$exponentialCounter","fixedCounter","linearCounter","exponentialCounter","stop","limit","onclick","innerText","toString"],"mappings":"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","file":"index.9f1a1801502f6dbdd69b.js","sourcesContent":["export const CANCEL_TOKEN = 'CANCEL_TOKEN'\n\nexport const timeout = (promise: Promise<any>, interval: number) => {\n  return new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => reject(new Error('Task timeout')), interval)\n\n    promise.then(result => {\n      clearTimeout(timeoutId)\n      resolve(result)\n    })\n  })\n}\n\nexport const delay = (interval: number) => new Promise(resolve => {\n  setTimeout(resolve, interval)\n})\n","type GetNextInterval = (count: number, strategy: Strategy) => number\n\ninterface FixedIntervalStrategy {\n  interval: number\n  getNextInterval: GetNextInterval\n}\n\ninterface LinearBackoffStrategy {\n  start: number\n  increment: number\n  getNextInterval: GetNextInterval\n}\n\ninterface ExponentialBackoffStrategy {\n  min: number\n  max: number\n  getNextInterval: GetNextInterval\n}\n\ntype StrategyName = 'fixed-interval' | 'linear-backoff' | 'exponential-backoff'\ntype Strategy = FixedIntervalStrategy | LinearBackoffStrategy | ExponentialBackoffStrategy\n\nexport interface Options {\n  taskFn: Function // 轮询任务\n  strategy?: StrategyName // 轮询策略\n  masterTimeout?: number // 整个轮询过程的 timeout\n  shouldContinue: (err: Error | null, result?: any) => boolean // 当次轮询后是否需要继续\n  taskTimeout?: number // 轮询任务的 timeout\n  retries?: number //轮询任务失败后重试次数\n  // fixed-interval 策略\n  interval?: number // 轮询周期\n  // linear-backoff 策略\n  start?: number\n  increment?: number\n  // exponential-backoff 策略\n  min?: number\n  max?: number\n}\n\nexport const strategies = {\n  'fixed-interval': {\n    defaults: {\n      interval: 1000\n    },\n    getNextInterval: function(count: number, options: Options) {\n      return options.interval;\n    }\n  },\n\n  'linear-backoff': {\n    defaults: {\n      start: 1000,\n      increment: 1000\n    },\n    getNextInterval: function(count: number, options: Options) {\n      return options.start + options.increment * count;\n    }\n  },\n\n  'exponential-backoff': {\n    defaults: {\n      min: 1000,\n      max: 30000\n    },\n    getNextInterval: function(count: number, options: Options) {\n      return Math.min(options.max, Math.round(Math.random() * (Math.pow(2, count) * 1000 - options.min) + options.min));\n    }\n  }\n};\n","import {CANCEL_TOKEN, delay, timeout} from './utils'\nimport {Options, strategies} from './contants'\n\nconst promisePoller = (options: Options) => {\n  const strategy = strategies[options.strategy] || strategies['fixed-interval']\n\n  const mergedOptions = {...strategy.defaults, ...options}\n\n  const {taskFn, masterTimeout, taskTimeout, shouldContinue, retries = 5} = mergedOptions\n\n  let polling = true\n  let timeoutId: null | number\n  let rejections: Array<Error | string> = []\n  let retriesRemain = retries\n\n  return new Promise((resolve, reject) => {\n    // 整个轮询过程超时\n    if (masterTimeout) {\n      timeoutId = window.setTimeout(() => {\n        reject(new Error('Master timeout'))\n        polling = false\n      }, masterTimeout)\n    }\n\n    // 轮询函数\n    const poll = () => {\n      let taskResult = taskFn()\n\n      // 同步结束任务\n      if (taskResult === false) {\n        taskResult = Promise.reject(taskResult)\n        reject(rejections)\n        polling = false\n      }\n\n      let taskPromise = Promise.resolve(taskResult)\n\n      if (taskTimeout) {\n        taskPromise = timeout(taskPromise, taskTimeout)\n      }\n\n      taskPromise\n        .then(result => {\n          if (shouldContinue(null, result)) {\n            const nextInterval = strategy.getNextInterval(retriesRemain, mergedOptions)\n            // 继续轮询\n            delay(nextInterval).then(poll)\n          } else {\n            // 不需要轮询，有 timeoutId 则清除\n            if (timeoutId !== null) {\n              clearTimeout(timeoutId)\n            }\n            // 结束并返回最后一次 taskFn 的结果\n            resolve(result)\n          }\n        })\n        .catch((error: Error) => {\n          // 异步结束任务\n          if (error.message === CANCEL_TOKEN) {\n            reject(rejections)\n            polling = false\n          }\n\n          rejections.push(error)\n\n          if (--retriesRemain === 0 || !shouldContinue(error)) {\n            // 不需要轮询\n            reject(rejections)\n          } else if (polling) {\n            const nextInterval = strategy.getNextInterval(retriesRemain, options)\n            // 重试轮询\n            delay(nextInterval).then(poll);\n          }\n        })\n    }\n\n    // 第一次轮询\n    poll()\n  })\n}\n\nexport default promisePoller\n","import promisePoller from './lib/index'\nimport {CANCEL_TOKEN} from \"./lib/utils\"\n\nconst $start = document.querySelector<HTMLButtonElement>('#start')\nconst $asyncStop = document.querySelector<HTMLButtonElement>('#async-stop')\n\nconst $fixedCounter = document.querySelector<HTMLParagraphElement>('#fixed-counter')\nconst $linearCounter = document.querySelector<HTMLParagraphElement>('#linear-counter')\nconst $exponentialCounter = document.querySelector<HTMLParagraphElement>('#exponential-counter')\n\nlet fixedCounter = 0\nlet linearCounter = 0\nlet exponentialCounter = 0\n\nlet stop = false\n\nconst limit = 99999\n\n$start.onclick = async () => {\n  promisePoller({\n    strategy: 'fixed-interval',\n    interval: 100,\n    taskFn: async () => {\n      if (stop) {\n        throw new Error(CANCEL_TOKEN)\n      }\n\n      fixedCounter += 1\n      $fixedCounter.innerText = fixedCounter.toString()\n    },\n    shouldContinue: () => fixedCounter < limit,\n  })\n  promisePoller({\n    strategy: 'linear-backoff',\n    start: 100,\n    increment: 100,\n    taskFn : async () => {\n      if (stop) {\n        throw new Error(CANCEL_TOKEN)\n      }\n\n      linearCounter += 1\n      $linearCounter.innerText = linearCounter.toString()\n    },\n    shouldContinue: () => linearCounter < limit\n  })\n  promisePoller({\n    strategy: 'exponential-backoff',\n    min: 100,\n    max: 3000,\n    taskFn : async () => {\n      if (stop) {\n        throw new Error(CANCEL_TOKEN)\n      }\n\n      exponentialCounter += 1\n      $exponentialCounter.innerText = exponentialCounter.toString()\n    },\n    shouldContinue: () => linearCounter < limit\n  })\n}\n\n$asyncStop.onclick = () => stop = true\n"],"sourceRoot":""}